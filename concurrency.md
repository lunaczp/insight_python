### 并发浅见

#### 什么是并发

并发是在一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态。
**并发与并行的联系**
1. 并发是同一时间内应对(dealing with)多件事情的能力；并行是同一时刻做(doing)多见事情的能力。
2. 并发提供了一种方式可以让我们能够设计一种方案将问题(非必须的)并行的解决。
3. 不同的并发设计能导致不同的并行方式。

#### 为什么要有并发
提供系统的资源利用率，包括 CPU，磁盘，网络，等

#### 好的并发模型标准
提供及时响应，高效，容错，简单的服务。

#### 常见的并发模型
##### 进程，线程，锁
**基础概念**
进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。线程是操作系统能够运行运算调度的最小单位。
进程线程最大的区别线程运行在共享的内存地址空间里，共享堆的资源。而进程运行在不同的内存地址空间里，不共享堆的资源。可以把进程理解为一组共享地址空间的线程的集合。
**调度**
在 Linux 下 scheduler 调度的单位是可以调度的 task。
task 可以是

 1. 一个单线程的进程
 2. 一个多线程进程中的线程
 
换句话说多线程的进程中的线程和单线程的进程调度时没有区别，对于多线程的进程操作系统是不调度进程的，调度的是进程中单独的线程。总体上讲在 Linux 调度时不区分进程和线程。
因为进程需要在 CPU 上运行， scheduler 就是控制，协调进程对于 CPU 的竞争，即按一定的调度算法从就绪队列中选择一个进程，把 CPU 的使用权交给被选中的进程如果没有就绪进程，系统会安排一个系统空闲线程。
目前 Linux 采取的调度算法是 [Completely Fair Scheduler][1] ，这个算法采用了红黑树的数据结构，红黑树中的节点是以处理器的执行时间为索引的，为每个进程计算一个最大的执行时间。这个时间是以所有进程完全平等共享 CPU 的处理能力为基础的。当 scheduler 调度到一个新进程运行时，会按照以下步骤处理

 1. 最左侧的节点的进程被选中执行
 2. 如果进程执行结束，进程节点会从红黑树中删除
 3. 如果进程达到了最大的运行时间或者停止了会根据最新的运行时间插入红黑树中
 4. 回到第一步，最左侧的进程被选中，持续整个流程

http://stackoverflow.com/questions/15601155/does-linux-schedule-a-process-or-a-thread
http://stackoverflow.com/questions/11998974/linux-threads-and-process-scheduling-priorities
http://stackoverflow.com/questions/8463741/how-linux-handles-threads-and-process-scheduling


  [1]: https://www.wikiwand.com/en/Completely_Fair_Scheduler
